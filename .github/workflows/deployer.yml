name: Deploy new upstream release to Vercel (Webhook Triggered)

on:
  workflow_dispatch:
    inputs:
      release_tag: 
        description: 'The upstream release tag from webhook'
        required: true
        type: string
      release_name:
        description: 'The name of the upstream release (from webhook)'
        required: false
        type: string
      release_url:
        description: 'The URL to the upstream release notes (from webhook)'
        required: false
        type: string
      upstream_event_timestamp: 
        description: 'Webhook event timestamp (ms) from webhook processor'
        required: true 
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history

      - name: Import GPG key
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --yes --import
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf

      - name: Configure GPG for Git
        run: |
          git config --global user.signingkey $(gpg --list-secret-keys --keyid-format LONG | grep sec | awk '{print $2}' | cut -d'/' -f2)
          git config --global commit.gpgSign true
          git config --global user.name "GitHub Actions"
          git config --global user.email "196231098+hedgie-svc@users.noreply.github.com"

      - name: Set Upstream Release Tag from Webhook Input
        id: set_upstream_tag
        run: |
          echo "Triggered by: Webhook (workflow_dispatch)"
          FULL_RELEASE_TAG="${{ github.event.inputs.release_tag }}"
          echo "Received upstream release_tag: ${FULL_RELEASE_TAG}"

          # Validate input format
          if [[ ! "${FULL_RELEASE_TAG}" =~ ^release/v ]]; then
            echo "Error: Webhook provided release_tag '${FULL_RELEASE_TAG}' is not in the expected 'release/vX.Y.Z' format."
            exit 1
          fi

          # Set LATEST_TAG env var
          echo "LATEST_TAG=${FULL_RELEASE_TAG}" >> $GITHUB_ENV

          # Perform string manipulation using shell parameter expansion
          LATEST_VERSION_SHELL_VAR="${FULL_RELEASE_TAG#release/v}"
          echo "LATEST_VERSION=${LATEST_VERSION_SHELL_VAR}" >> $GITHUB_ENV
          
          echo "Successfully set LATEST_TAG=${FULL_RELEASE_TAG} and LATEST_VERSION=${LATEST_VERSION_SHELL_VAR}"
          
      - name: Identify the latest production release
        run: |
          # Ensure origin is set correctly if not default
          git remote set-url origin git@github.com:dydxopsdao/v4-web.git
          git fetch origin main --tags # Ensure origin is up-to-date with tags

          # Store the full tag in a shell variable first
          PRODUCTION_TAG_FROM_GIT=$(git tag --merged origin/main --sort=-v:refname | grep '^release/v' | head -n 1)
          echo "Latest production tag on main branch: ${PRODUCTION_TAG_FROM_GIT}"

          if [ -z "$PRODUCTION_TAG_FROM_GIT" ]; then
              echo "No production tags found on main branch matching 'release/v*'. Assuming first deployment or using a base version."
              echo "PRODUCTION_TAG=release/v0.0.0" >> $GITHUB_ENV # Fallback for comparison
              echo "PRODUCTION_VERSION=0.0.0" >> $GITHUB_ENV      # Corresponding version for fallback
          else
              echo "PRODUCTION_TAG=${PRODUCTION_TAG_FROM_GIT}" >> $GITHUB_ENV
              # Perform string manipulation using shell parameter expansion
              PRODUCTION_VERSION_SHELL_VAR="${PRODUCTION_TAG_FROM_GIT#release/v}"
              echo "PRODUCTION_VERSION=${PRODUCTION_VERSION_SHELL_VAR}" >> $GITHUB_ENV
          fi

      - name: Determine if New Version is Deployable
        id: version_check 
        run: |
          echo "Production Version: ${{ env.PRODUCTION_VERSION }} (${{ env.PRODUCTION_TAG }})"
          echo "Latest Upstream (from webhook): ${{ env.LATEST_VERSION }} (${{ env.LATEST_TAG }})"

          # We deploy if LATEST_VERSION is strictly newer than PRODUCTION_VERSION
          if printf '%s\n' "${{ env.LATEST_VERSION }}" "${{ env.PRODUCTION_VERSION }}" | sort -V -C && [[ "${{ env.LATEST_VERSION }}" != "${{ env.PRODUCTION_VERSION }}" ]]; then
            # This condition means LATEST_VERSION > PRODUCTION_VERSION
            echo "New version detected for deployment: ${{ env.LATEST_TAG }}"
            echo "::set-output name=should_deploy::true"
          else
            echo "Latest upstream version (${{ env.LATEST_TAG }}) is not newer than or is the same as current production (${{ env.PRODUCTION_TAG }}). No deployment needed."
            echo "::set-output name=should_deploy::false"
          fi

      - name: Fetch Upstream Tag for Rebase (if deploying)
        if: steps.version_check.outputs.should_deploy == 'true'
        run: |
          echo "Fetching upstream tag ${{ env.LATEST_TAG }} to ensure it's available for rebase..."
          git remote add upstream_source_repo git@github.com:dydxprotocol/v4-web.git || echo "Upstream remote already exists or failed to add (non-critical if tag is already available)"
          # Try fetching the specific tag with enough history for rebase (e.g. --depth=50, or adjust as needed)
          # If specific tag fetch is problematic, fetching all tags is a more robust fallback.
          echo "Attempting to fetch specific tag: ${{ env.LATEST_TAG }}"
          if ! git fetch upstream_source_repo --depth=50 ${{ env.LATEST_TAG }}; then
            echo "Failed to fetch specific tag with depth. Attempting to fetch all tags from upstream_source_repo."
            if ! git fetch upstream_source_repo --tags; then
              echo "Error: Failed to fetch tags from upstream_source_repo."
              exit 1
            fi
          fi
          # Verify tag exists locally
          if ! git rev-parse --verify ${{ env.LATEST_TAG }}^{commit} > /dev/null; then
            echo "Error: Tag ${{ env.LATEST_TAG }} not found locally after fetch attempts."
            exit 1
          fi
          echo "Tag ${{ env.LATEST_TAG }} is available locally."

      - name: Branch Test Safety - Skip Actual Git Push
        if: steps.version_check.outputs.should_deploy == 'true' && github.ref_name != 'main'
        run: |
          echo "BRANCH TEST: New version ${{ env.LATEST_TAG }} detected on branch ${{ github.ref_name }}."
          echo "Actual Git push operations will be SKIPPED for this test run on a non-main branch."
          echo "::set-output name=branch_test_skip_push::true"
        id: branch_test_safety

      - name: Create a new release branch for Vercel deployment
        if: steps.version_check.outputs.should_deploy == 'true' && steps.branch_test_safety.outputs.branch_test_skip_push != 'true'
        run: |
          echo "Creating new branch dos-${{ env.LATEST_VERSION }} from origin/main and rebasing with ${{ env.LATEST_TAG }}"
          git checkout -b dos-${{ env.LATEST_VERSION }} origin/main
          git rebase ${{ env.LATEST_TAG }}
          git push --set-upstream origin dos-${{ env.LATEST_VERSION }}

      - name: Reset main to the feature branch for production deployment
        if: steps.version_check.outputs.should_deploy == 'true' && steps.branch_test_safety.outputs.branch_test_skip_push != 'true'
        run: |
          echo "Resetting main to origin/dos-${{ env.LATEST_VERSION }} and force pushing"
          git checkout main
          git reset --hard origin/dos-${{ env.LATEST_VERSION }}
          sleep 5 
          git push --force origin main

      - name: Final Log
        if: always() 
        run: |
          echo "Workflow finished."
          echo "Should deploy: ${{ steps.version_check.outputs.should_deploy || 'false' }}"
          echo "Branch test skip push: ${{ steps.branch_test_safety.outputs.branch_test_skip_push || 'false' }}"
          echo "Upstream tag used: ${{ env.LATEST_TAG || 'N/A' }}"
