name: Deploy new upstream release to Vercel (Webhook Triggered)

on:
  workflow_dispatch:
    inputs:
      release_tag: 
        description: 'The upstream release tag from webhook'
        required: true
        type: string
      release_name:
        description: 'The name of the upstream release (from webhook)'
        required: false # Set to true if your Lambda always sends a non-empty value and you require it
        type: string
      release_url:
        description: 'The URL to the upstream release notes (from webhook)'
        required: false # Set to true if your Lambda always sends a non-empty value and you require it
        type: string
      upstream_event_timestamp: 
        description: 'Webhook event timestamp (ms) from webhook processor'
        required: true 
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch full history

      - name: Import GPG key
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --yes --import
          echo "pinentry-mode loopback" >> ~/.gnupg/gpg.conf

      - name: Configure GPG for Git
        run: |
          git config --global user.signingkey $(gpg --list-secret-keys --keyid-format LONG | grep sec | awk '{print $2}' | cut -d'/' -f2)
          git config --global commit.gpgSign true
          git config --global user.name "GitHub Actions"
          git config --global user.email "196231098+hedgie-svc@users.noreply.github.com"

      - name: Set Upstream Release Tag from Webhook Input
        id: set_upstream_tag
        run: |
          echo "Triggered by: Webhook (workflow_dispatch)"
          FULL_RELEASE_TAG="${{ github.event.inputs.release_tag }}"
          echo "Received upstream release_tag: ${FULL_RELEASE_TAG}"

          # Validate input format
          if [[ ! "${FULL_RELEASE_TAG}" =~ ^release/v ]]; then
            echo "Error: Webhook provided release_tag '${FULL_RELEASE_TAG}' is not in the expected 'release/vX.Y.Z' format."
            exit 1
          fi

          # Set LATEST_TAG env var
          echo "LATEST_TAG=${FULL_RELEASE_TAG}" >> $GITHUB_ENV

          # Perform string manipulation using shell parameter expansion
          LATEST_VERSION_SHELL_VAR="${FULL_RELEASE_TAG#release/v}"
          echo "LATEST_VERSION=${LATEST_VERSION_SHELL_VAR}" >> $GITHUB_ENV
          
          echo "Successfully set LATEST_TAG=${FULL_RELEASE_TAG} and LATEST_VERSION=${LATEST_VERSION_SHELL_VAR}"
          
      - name: Identify the latest production release
        run: |
          # Ensure origin is set correctly if not default
          git remote set-url origin git@github.com:dydxopsdao/v4-web.git
          git fetch origin main --tags # Ensure origin is up-to-date with tags

          PRODUCTION_TAG=$(git tag --merged origin/main --sort=-v:refname | grep '^release/v' | head -n 1)
          echo "Latest production tag on main branch: ${PRODUCTION_TAG}"
          if [ -z "$PRODUCTION_TAG" ]; then
              echo "No production tags found on main branch matching 'release/v*'. Assuming first deployment or using a base version."
              echo "PRODUCTION_TAG=release/v0.0.0" >> $GITHUB_ENV # Fallback for comparison
          else
              echo "PRODUCTION_TAG=${PRODUCTION_TAG}" >> $GITHUB_ENV
          fi
          echo "PRODUCTION_VERSION=${{ env.PRODUCTION_TAG#release/v }}" >> $GITHUB_ENV

      - name: Determine if New Version is Deployable
        id: version_check # Give this step an ID
        run: |
          echo "Production Version: ${{ env.PRODUCTION_VERSION }} (${{ env.PRODUCTION_TAG }})"
          echo "Latest Upstream (from webhook): ${{ env.LATEST_VERSION }} (${{ env.LATEST_TAG }})"

          # We deploy if LATEST_VERSION is strictly newer than PRODUCTION_VERSION
          if printf '%s\n' "${{ env.LATEST_VERSION }}" "${{ env.PRODUCTION_VERSION }}" | sort -V -C && [[ "${{ env.LATEST_VERSION }}" != "${{ env.PRODUCTION_VERSION }}" ]]; then
            # This condition means LATEST_VERSION > PRODUCTION_VERSION
            echo "New version detected for deployment: ${{ env.LATEST_TAG }}"
            echo "::set-output name=should_deploy::true"
          else
            echo "Latest upstream version (${{ env.LATEST_TAG }}) is not newer than or is the same as current production (${{ env.PRODUCTION_TAG }}). No deployment needed."
            echo "::set-output name=should_deploy::false"
          fi

      # This step ensures the LATEST_TAG (which comes from dydxprotocol/v4-web) is available locally for rebase
      - name: Fetch Upstream Tag for Rebase (if deploying)
        if: steps.version_check.outputs.should_deploy == 'true'
        run: |
          echo "Fetching upstream tag ${{ env.LATEST_TAG }} to ensure it's available for rebase..."
          git remote add upstream_source_repo git@github.com:dydxprotocol/v4-web.git || echo "Upstream remote already exists or failed to add (non-critical if tag is already available)"
          git fetch upstream_source_repo --tags --depth=1 ${{ env.LATEST_TAG }} || echo "Failed to fetch specific tag, will try fetching all tags. This might happen if tag is not directly on a branch tip."
          # Fallback to fetching all tags if specific tag fetch fails (e.g. not on a tip)
          if [ $? -ne 0 ]; then
            echo "Fetching all upstream tags as specific tag fetch failed..."
            git fetch upstream_source_repo --tags
          fi
          # Verify tag exists locally
          git rev-parse --verify ${{ env.LATEST_TAG }}^{commit} > /dev/null || (echo "Error: Tag ${{ env.LATEST_TAG }} not found locally after fetch." && exit 1)
          echo "Tag ${{ env.LATEST_TAG }} is available."


      # --- BRANCH TESTING SAFETY CHECK ---
      # If running on a branch that is NOT 'main', and we should deploy, this step will "complete" the test.
      - name: Branch Test Safety - Skip Actual Git Push
        if: steps.version_check.outputs.should_deploy == 'true' && github.ref_name != 'main'
        run: |
          echo "BRANCH TEST: New version ${{ env.LATEST_TAG }} detected on branch ${{ github.ref_name }}."
          echo "Actual Git push operations will be SKIPPED for this test run on a non-main branch."
          echo "::set-output name=branch_test_skip_push::true"
        id: branch_test_safety

      # --- Actual Git Operations ---
      - name: Create a new release branch for Vercel deployment
        if: steps.version_check.outputs.should_deploy == 'true' && steps.branch_test_safety.outputs.branch_test_skip_push != 'true'
        run: |
          echo "Creating new branch dos-${{ env.LATEST_VERSION }} from origin/main and rebasing with ${{ env.LATEST_TAG }}"
          git checkout -b dos-${{ env.LATEST_VERSION }} origin/main
          git rebase ${{ env.LATEST_TAG }}
          git push --set-upstream origin dos-${{ env.LATEST_VERSION }}

      - name: Reset main to the feature branch for production deployment
        if: steps.version_check.outputs.should_deploy == 'true' && steps.branch_test_safety.outputs.branch_test_skip_push != 'true'
        run: |
          echo "Resetting main to origin/dos-${{ env.LATEST_VERSION }} and force pushing"
          git checkout main
          git reset --hard origin/dos-${{ env.LATEST_VERSION }}
          sleep 5 # Kept as per discussion
          git push --force origin main

      - name: Final Log
        if: always() # Run always to see the final status
        run: |
          echo "Workflow finished."
          echo "Should deploy: ${{ steps.version_check.outputs.should_deploy || 'false' }}"
          echo "Branch test skip push: ${{ steps.branch_test_safety.outputs.branch_test_skip_push || 'false' }}"
          echo "Upstream tag used: ${{ env.LATEST_TAG || 'N/A' }}"
